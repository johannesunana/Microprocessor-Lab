   1               		.file	"dht.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	dht_getdata
  12               	dht_getdata:
  13               	.LFB7:
  14               		.file 1 "src/dht.c"
   1:src/dht.c     **** /*
   2:src/dht.c     **** DHT Library 0x03
   3:src/dht.c     **** 
   4:src/dht.c     **** copyright (c) Davide Gironi, 2012
   5:src/dht.c     **** 
   6:src/dht.c     **** Released under GPLv3.
   7:src/dht.c     **** Please refer to LICENSE file for licensing information.
   8:src/dht.c     **** */
   9:src/dht.c     **** 
  10:src/dht.c     **** #include <stdio.h>
  11:src/dht.c     **** #include <string.h>
  12:src/dht.c     **** #include <avr/io.h>
  13:src/dht.c     **** #include <util/delay.h>
  14:src/dht.c     **** 
  15:src/dht.c     **** #include "lib/dht.h"
  16:src/dht.c     **** 
  17:src/dht.c     **** /*
  18:src/dht.c     ****  * get data from sensor
  19:src/dht.c     ****  */
  20:src/dht.c     **** int8_t dht_getdata(int8_t *temperature, int8_t *humidity) {
  15               		.loc 1 20 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF92      		push r12
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 12, -2
  22 0002 DF92      		push r13
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 13, -3
  26 0004 EF92      		push r14
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 14, -4
  30 0006 FF92      		push r15
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 15, -5
  34 0008 0F93      		push r16
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 16, -6
  38 000a 1F93      		push r17
  39               	.LCFI5:
  40               		.cfi_def_cfa_offset 8
  41               		.cfi_offset 17, -7
  42 000c CF93      		push r28
  43               	.LCFI6:
  44               		.cfi_def_cfa_offset 9
  45               		.cfi_offset 28, -8
  46 000e DF93      		push r29
  47               	.LCFI7:
  48               		.cfi_def_cfa_offset 10
  49               		.cfi_offset 29, -9
  50 0010 00D0      		rcall .
  51 0012 00D0      		rcall .
  52 0014 1F92      		push __zero_reg__
  53               	.LCFI8:
  54               		.cfi_def_cfa_offset 15
  55 0016 CDB7      		in r28,__SP_L__
  56 0018 DEB7      		in r29,__SP_H__
  57               	.LCFI9:
  58               		.cfi_def_cfa_register 28
  59               	/* prologue: function */
  60               	/* frame size = 5 */
  61               	/* stack size = 13 */
  62               	.L__stack_usage = 13
  63 001a 6C01      		movw r12,r24
  64               	.LVL1:
  21:src/dht.c     **** 
  22:src/dht.c     **** 	uint8_t bits[5];
  23:src/dht.c     **** 	uint8_t i,j = 0;
  24:src/dht.c     **** 
  25:src/dht.c     **** 	memset(bits, 0, sizeof(bits));
  65               		.loc 1 25 0
  66 001c FE01      		movw r30,r28
  67 001e 3196      		adiw r30,1
  68 0020 85E0      		ldi r24,lo8(5)
  69               	.LVL2:
  70 0022 DF01      		movw r26,r30
  71               		0:
  72 0024 1D92      		st X+,__zero_reg__
  73 0026 8A95      		dec r24
  74 0028 01F4      		brne 0b
  26:src/dht.c     **** 
  27:src/dht.c     **** 	//reset port
  28:src/dht.c     **** 	DHT_DDR |= (1<<DHT_INPUTPIN); //output
  75               		.loc 1 28 0
  76 002a 569A      		sbi 0xa,6
  29:src/dht.c     **** 	DHT_PORT |= (1<<DHT_INPUTPIN); //high
  77               		.loc 1 29 0
  78 002c 5E9A      		sbi 0xb,6
  79               	.LVL3:
  80               	.LBB17:
  81               	.LBB18:
  82               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  83               		.loc 2 187 0
  84 002e BFEF      		ldi r27,lo8(319999)
  85 0030 21EE      		ldi r18,hi8(319999)
  86 0032 84E0      		ldi r24,hlo8(319999)
  87 0034 B150      	1:	subi r27,1
  88 0036 2040      		sbci r18,0
  89 0038 8040      		sbci r24,0
  90 003a 01F4      		brne 1b
  91 003c 00C0      		rjmp .
  92 003e 0000      		nop
  93               	.LVL4:
  94               	.LBE18:
  95               	.LBE17:
  30:src/dht.c     **** 	_delay_ms(100);
  31:src/dht.c     **** 
  32:src/dht.c     **** 	//send request
  33:src/dht.c     **** 	DHT_PORT &= ~(1<<DHT_INPUTPIN); //low
  96               		.loc 1 33 0
  97 0040 5E98      		cbi 0xb,6
  98               	.LVL5:
  99               	.LBB19:
 100               	.LBB20:
 101               		.loc 2 187 0
 102 0042 9FEF      		ldi r25,lo8(57599)
 103 0044 A0EE      		ldi r26,hi8(57599)
 104 0046 B0E0      		ldi r27,hlo8(57599)
 105 0048 9150      	1:	subi r25,1
 106 004a A040      		sbci r26,0
 107 004c B040      		sbci r27,0
 108 004e 01F4      		brne 1b
 109 0050 00C0      		rjmp .
 110 0052 0000      		nop
 111               	.LVL6:
 112               	.LBE20:
 113               	.LBE19:
  34:src/dht.c     **** 	_delay_ms(18);
  35:src/dht.c     **** 
  36:src/dht.c     **** 	DHT_PORT |= (1<<DHT_INPUTPIN); //high
 114               		.loc 1 36 0
 115 0054 5E9A      		sbi 0xb,6
  37:src/dht.c     **** 	DHT_DDR &= ~(1<<DHT_INPUTPIN); //input
 116               		.loc 1 37 0
 117 0056 5698      		cbi 0xa,6
 118               	.LVL7:
 119               	.LBB21:
 120               	.LBB22:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 121               		.loc 2 276 0
 122 0058 25ED      		ldi r18,lo8(-43)
 123 005a 2A95      	1:	dec r18
 124 005c 01F4      		brne 1b
 125 005e 0000      		nop
 126               	.LVL8:
 127               	.LBE22:
 128               	.LBE21:
  38:src/dht.c     **** 	_delay_us(40);
  39:src/dht.c     **** 
  40:src/dht.c     **** 	//check start condition 1
  41:src/dht.c     **** 	if((DHT_PIN & (1<<DHT_INPUTPIN))) {
 129               		.loc 1 41 0
 130 0060 4E9B      		sbis 0x9,6
 131 0062 00C0      		rjmp .L2
 132               	.LVL9:
 133               	.L4:
  42:src/dht.c     **** 		return -1;
 134               		.loc 1 42 0
 135 0064 8FEF      		ldi r24,lo8(-1)
 136 0066 00C0      		rjmp .L3
 137               	.LVL10:
 138               	.L2:
 139               	.LBB23:
 140               	.LBB24:
 141               		.loc 2 276 0
 142 0068 8FE3      		ldi r24,lo8(319)
 143 006a 91E0      		ldi r25,hi8(319)
 144 006c 0197      	1:	sbiw r24,1
 145 006e 01F4      		brne 1b
 146 0070 00C0      		rjmp .
 147 0072 0000      		nop
 148               	.LVL11:
 149               	.LBE24:
 150               	.LBE23:
  43:src/dht.c     **** 	}
  44:src/dht.c     **** 	_delay_us(80);
  45:src/dht.c     **** 	//check start condition 2
  46:src/dht.c     **** 	if(!(DHT_PIN & (1<<DHT_INPUTPIN))) {
 151               		.loc 1 46 0
 152 0074 4E9B      		sbis 0x9,6
 153 0076 00C0      		rjmp .L4
 154               	.LVL12:
 155               	.LBB25:
 156               	.LBB26:
 157               		.loc 2 276 0
 158 0078 AFE3      		ldi r26,lo8(319)
 159 007a B1E0      		ldi r27,hi8(319)
 160 007c 1197      	1:	sbiw r26,1
 161 007e 01F4      		brne 1b
 162 0080 00C0      		rjmp .
 163 0082 0000      		nop
 164               	.LVL13:
 165 0084 8E01      		movw r16,r28
 166 0086 0A5F      		subi r16,-6
 167 0088 1F4F      		sbci r17,-1
 168               	.LBE26:
 169               	.LBE25:
 170               	.LBB27:
  47:src/dht.c     **** 		return -1;
  48:src/dht.c     **** 	}
  49:src/dht.c     **** 	_delay_us(80);
  50:src/dht.c     **** 
  51:src/dht.c     **** 	//read the data
  52:src/dht.c     **** 	uint16_t timeoutcounter = 0;
  53:src/dht.c     **** 	for (j=0; j<5; j++) { //read 5 byte
  54:src/dht.c     **** 		uint8_t result=0;
  55:src/dht.c     **** 		for(i=0; i<8; i++) {//read every bit
  56:src/dht.c     **** 			timeoutcounter = 0;
  57:src/dht.c     **** 			while(!(DHT_PIN & (1<<DHT_INPUTPIN))) { //wait for an high input (non blocking)
  58:src/dht.c     **** 				timeoutcounter++;
  59:src/dht.c     **** 				if(timeoutcounter > DHT_TIMEOUT) {
  60:src/dht.c     **** 					return -1; //timeout
  61:src/dht.c     **** 				}
  62:src/dht.c     **** 			}
  63:src/dht.c     **** 			_delay_us(30);
  64:src/dht.c     **** 			if(DHT_PIN & (1<<DHT_INPUTPIN)) //if input is high after 30 us, get result
  65:src/dht.c     **** 				result |= (1<<(7-i));
 171               		.loc 1 65 0
 172 008a EE24      		clr r14
 173 008c E394      		inc r14
 174 008e F12C      		mov r15,__zero_reg__
 175               	.LVL14:
 176               	.L5:
 177               	.LBE27:
  20:src/dht.c     **** 
 178               		.loc 1 20 0
 179 0090 27E0      		ldi r18,lo8(7)
 180 0092 30E0      		ldi r19,0
 181 0094 90E0      		ldi r25,0
 182               	.LVL15:
 183               	.L11:
 184 0096 49EC      		ldi r20,lo8(-55)
 185 0098 50E0      		ldi r21,0
 186               	.L6:
 187               	.LVL16:
 188               	.LBB30:
  57:src/dht.c     **** 				timeoutcounter++;
 189               		.loc 1 57 0
 190 009a 4E99      		sbic 0x9,6
 191 009c 00C0      		rjmp .L27
 192               	.LVL17:
 193 009e 4150      		subi r20,1
 194 00a0 5109      		sbc r21,__zero_reg__
 195               	.LVL18:
  59:src/dht.c     **** 					return -1; //timeout
 196               		.loc 1 59 0
 197 00a2 01F4      		brne .L6
 198 00a4 00C0      		rjmp .L4
 199               	.L27:
 200               	.LVL19:
 201               	.LBB28:
 202               	.LBB29:
 203               		.loc 2 276 0
 204 00a6 B0EA      		ldi r27,lo8(-96)
 205 00a8 BA95      	1:	dec r27
 206 00aa 01F4      		brne 1b
 207               	.LVL20:
 208               	.LBE29:
 209               	.LBE28:
  64:src/dht.c     **** 				result |= (1<<(7-i));
 210               		.loc 1 64 0
 211 00ac 4E9B      		sbis 0x9,6
 212 00ae 00C0      		rjmp .L8
 213               		.loc 1 65 0
 214 00b0 A701      		movw r20,r14
 215               	.LVL21:
 216 00b2 022E      		mov r0,r18
 217 00b4 00C0      		rjmp 2f
 218               		1:
 219 00b6 440F      		lsl r20
 220               		2:
 221 00b8 0A94      		dec r0
 222 00ba 02F4      		brpl 1b
 223 00bc 942B      		or r25,r20
 224               	.LVL22:
 225               	.L8:
  66:src/dht.c     **** 			timeoutcounter = 0;
  67:src/dht.c     **** 			while(DHT_PIN & (1<<DHT_INPUTPIN)) { //wait until input get low (non blocking)
 226               		.loc 1 67 0
 227 00be 49EC      		ldi r20,lo8(-55)
 228 00c0 50E0      		ldi r21,0
 229               	.LVL23:
 230               	.L9:
 231 00c2 4E9B      		sbis 0x9,6
 232 00c4 00C0      		rjmp .L28
 233               	.LVL24:
 234 00c6 4150      		subi r20,1
 235 00c8 5109      		sbc r21,__zero_reg__
 236               	.LVL25:
  68:src/dht.c     **** 				timeoutcounter++;
  69:src/dht.c     **** 				if(timeoutcounter > DHT_TIMEOUT) {
 237               		.loc 1 69 0
 238 00ca 01F4      		brne .L9
 239 00cc 00C0      		rjmp .L4
 240               	.L28:
 241               	.LVL26:
 242               	.LVL27:
 243 00ce 2150      		subi r18,1
 244 00d0 3109      		sbc r19,__zero_reg__
 245 00d2 00F4      		brcc .L11
  70:src/dht.c     **** 					return -1; //timeout
  71:src/dht.c     **** 				}
  72:src/dht.c     **** 			}
  73:src/dht.c     **** 		}
  74:src/dht.c     **** 		bits[j] = result;
 246               		.loc 1 74 0 discriminator 2
 247 00d4 9193      		st Z+,r25
 248               	.LBE30:
  53:src/dht.c     **** 		uint8_t result=0;
 249               		.loc 1 53 0 discriminator 2
 250 00d6 0E17      		cp r16,r30
 251 00d8 1F07      		cpc r17,r31
 252 00da 01F4      		brne .L5
  75:src/dht.c     **** 	}
  76:src/dht.c     **** 
  77:src/dht.c     **** 	//reset port
  78:src/dht.c     **** 	DHT_DDR |= (1<<DHT_INPUTPIN); //output
 253               		.loc 1 78 0
 254 00dc 569A      		sbi 0xa,6
  79:src/dht.c     **** 	DHT_PORT |= (1<<DHT_INPUTPIN); //low
 255               		.loc 1 79 0
 256 00de 5E9A      		sbi 0xb,6
 257               	.LVL28:
 258               	.LBB31:
 259               	.LBB32:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 260               		.loc 2 187 0
 261 00e0 9FEF      		ldi r25,lo8(319999)
 262 00e2 A1EE      		ldi r26,hi8(319999)
 263 00e4 B4E0      		ldi r27,hlo8(319999)
 264 00e6 9150      	1:	subi r25,1
 265 00e8 A040      		sbci r26,0
 266 00ea B040      		sbci r27,0
 267 00ec 01F4      		brne 1b
 268               	.LVL29:
 269 00ee 00C0      		rjmp .
 270 00f0 0000      		nop
 271               	.LVL30:
 272               	.LBE32:
 273               	.LBE31:
  80:src/dht.c     **** 	_delay_ms(100);
  81:src/dht.c     **** 
  82:src/dht.c     **** 	//check checksum
  83:src/dht.c     **** 	if ((uint8_t)(bits[0] + bits[1] + bits[2] + bits[3]) == bits[4]) {
 274               		.loc 1 83 0
 275 00f2 8981      		ldd r24,Y+1
 276 00f4 3B81      		ldd r19,Y+3
 277 00f6 9A81      		ldd r25,Y+2
 278 00f8 980F      		add r25,r24
 279 00fa 930F      		add r25,r19
 280 00fc 2C81      		ldd r18,Y+4
 281               	.LVL31:
 282 00fe 920F      		add r25,r18
 283 0100 2D81      		ldd r18,Y+5
 284 0102 9213      		cpse r25,r18
 285 0104 00C0      		rjmp .L4
  84:src/dht.c     **** 		//return temperature and humidity
  85:src/dht.c     **** 		*temperature = bits[2];
 286               		.loc 1 85 0
 287 0106 F601      		movw r30,r12
 288               	.LVL32:
 289 0108 3083      		st Z,r19
  86:src/dht.c     **** 		*humidity = bits[0];
 290               		.loc 1 86 0
 291 010a DB01      		movw r26,r22
 292 010c 8C93      		st X,r24
  87:src/dht.c     **** 		
  88:src/dht.c     **** 		return 0;
 293               		.loc 1 88 0
 294 010e 80E0      		ldi r24,0
 295               	.LVL33:
 296               	.L3:
 297               	/* epilogue start */
  89:src/dht.c     **** 	}
  90:src/dht.c     **** 
  91:src/dht.c     **** 	return -1;
  92:src/dht.c     **** }
 298               		.loc 1 92 0
 299 0110 0F90      		pop __tmp_reg__
 300 0112 0F90      		pop __tmp_reg__
 301 0114 0F90      		pop __tmp_reg__
 302 0116 0F90      		pop __tmp_reg__
 303 0118 0F90      		pop __tmp_reg__
 304 011a DF91      		pop r29
 305 011c CF91      		pop r28
 306 011e 1F91      		pop r17
 307 0120 0F91      		pop r16
 308 0122 FF90      		pop r15
 309 0124 EF90      		pop r14
 310 0126 DF90      		pop r13
 311 0128 CF90      		pop r12
 312               	.LVL34:
 313 012a 0895      		ret
 314               		.cfi_endproc
 315               	.LFE7:
 317               	.global	dht_gettemperature
 319               	dht_gettemperature:
 320               	.LFB8:
  93:src/dht.c     **** 
  94:src/dht.c     **** /*
  95:src/dht.c     ****  * get temperature
  96:src/dht.c     ****  */
  97:src/dht.c     **** int8_t dht_gettemperature(int8_t *temperature) {
 321               		.loc 1 97 0
 322               		.cfi_startproc
 323               	.LVL35:
 324 012c CF93      		push r28
 325               	.LCFI10:
 326               		.cfi_def_cfa_offset 3
 327               		.cfi_offset 28, -2
 328 012e DF93      		push r29
 329               	.LCFI11:
 330               		.cfi_def_cfa_offset 4
 331               		.cfi_offset 29, -3
 332 0130 1F92      		push __zero_reg__
 333               	.LCFI12:
 334               		.cfi_def_cfa_offset 5
 335 0132 CDB7      		in r28,__SP_L__
 336 0134 DEB7      		in r29,__SP_H__
 337               	.LCFI13:
 338               		.cfi_def_cfa_register 28
 339               	/* prologue: function */
 340               	/* frame size = 1 */
 341               	/* stack size = 3 */
 342               	.L__stack_usage = 3
  98:src/dht.c     **** 	int8_t humidity = 0;
 343               		.loc 1 98 0
 344 0136 1982      		std Y+1,__zero_reg__
  99:src/dht.c     **** 	return dht_getdata(temperature, &humidity);
 345               		.loc 1 99 0
 346 0138 BE01      		movw r22,r28
 347 013a 6F5F      		subi r22,-1
 348 013c 7F4F      		sbci r23,-1
 349 013e 0E94 0000 		call dht_getdata
 350               	.LVL36:
 351               	/* epilogue start */
 100:src/dht.c     **** }
 352               		.loc 1 100 0
 353 0142 0F90      		pop __tmp_reg__
 354 0144 DF91      		pop r29
 355 0146 CF91      		pop r28
 356 0148 0895      		ret
 357               		.cfi_endproc
 358               	.LFE8:
 360               	.global	dht_gethumidity
 362               	dht_gethumidity:
 363               	.LFB9:
 101:src/dht.c     **** 
 102:src/dht.c     **** /*
 103:src/dht.c     ****  * get humidity
 104:src/dht.c     ****  */
 105:src/dht.c     **** int8_t dht_gethumidity(int8_t *humidity) {
 364               		.loc 1 105 0
 365               		.cfi_startproc
 366               	.LVL37:
 367 014a CF93      		push r28
 368               	.LCFI14:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 28, -2
 371 014c DF93      		push r29
 372               	.LCFI15:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 29, -3
 375 014e 1F92      		push __zero_reg__
 376               	.LCFI16:
 377               		.cfi_def_cfa_offset 5
 378 0150 CDB7      		in r28,__SP_L__
 379 0152 DEB7      		in r29,__SP_H__
 380               	.LCFI17:
 381               		.cfi_def_cfa_register 28
 382               	/* prologue: function */
 383               	/* frame size = 1 */
 384               	/* stack size = 3 */
 385               	.L__stack_usage = 3
 106:src/dht.c     **** 	int8_t temperature = 0;
 386               		.loc 1 106 0
 387 0154 1982      		std Y+1,__zero_reg__
 107:src/dht.c     **** 	return dht_getdata(&temperature, humidity);
 388               		.loc 1 107 0
 389 0156 BC01      		movw r22,r24
 390 0158 CE01      		movw r24,r28
 391               	.LVL38:
 392 015a 0196      		adiw r24,1
 393 015c 0E94 0000 		call dht_getdata
 394               	.LVL39:
 395               	/* epilogue start */
 108:src/dht.c     **** }
 396               		.loc 1 108 0
 397 0160 0F90      		pop __tmp_reg__
 398 0162 DF91      		pop r29
 399 0164 CF91      		pop r28
 400 0166 0895      		ret
 401               		.cfi_endproc
 402               	.LFE9:
 404               	.global	dht_gettemperaturehumidity
 406               	dht_gettemperaturehumidity:
 407               	.LFB10:
 109:src/dht.c     **** 
 110:src/dht.c     **** /*
 111:src/dht.c     ****  * get temperature and humidity
 112:src/dht.c     ****  */
 113:src/dht.c     **** 	int8_t dht_gettemperaturehumidity(int8_t *temperature, int8_t *humidity) {
 408               		.loc 1 113 0
 409               		.cfi_startproc
 410               	.LVL40:
 411               	/* prologue: function */
 412               	/* frame size = 0 */
 413               	/* stack size = 0 */
 414               	.L__stack_usage = 0
 114:src/dht.c     **** 	return dht_getdata(temperature, humidity);
 415               		.loc 1 114 0
 416 0168 0C94 0000 		jmp dht_getdata
 417               	.LVL41:
 418               		.cfi_endproc
 419               	.LFE10:
 421               	.Letext0:
 422               		.file 3 "c:\\winavr-20100110\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 dht.c
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:2      *ABS*:0000003e __SP_H__
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:3      *ABS*:0000003d __SP_L__
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:4      *ABS*:0000003f __SREG__
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:6      *ABS*:00000001 __zero_reg__
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:12     .text:00000000 dht_getdata
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:319    .text:0000012c dht_gettemperature
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:362    .text:0000014a dht_gethumidity
C:\Users\JOHANN~1\AppData\Local\Temp\cc6alPga.s:406    .text:00000168 dht_gettemperaturehumidity

NO UNDEFINED SYMBOLS
